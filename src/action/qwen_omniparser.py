import re
import json
import torch

from action.base import Action, ActionInterface
from models.qwen_vl_model import Qwen2_5VLModel

from action.omniparser import analyze_ui_image

from utils.logging_utils import log_variable


class QwenOmniparserActionModel(ActionInterface, Qwen2_5VLModel):
    """
    ActionModel implentation for a Qwen model leveraging omniparser oÂ¡for UI grounding.
    """

    capabilities: list[str] = ["image", "text"]

    def __init__(self, model_name: str, *args, **kwargs):
        super().__init__(model_name, *args, **kwargs)

    def action(self, sys_prompt, user_prompt: str, *args, **kwargs) -> Action:
        # Process the image using OmniParser
        image = kwargs["image"]
        annotated_image, labels = analyze_ui_image(image)

        # Convert the processed image to a format suitable for the model
        kwargs["image"] = annotated_image

        user_prompt = f"{user_prompt} {list(map(lambda label: {'id': label['id'], 'content': label['content'], 'interactivity': label['interactivity']}, labels))}"
        # user_prompt = f"{user_prompt} {labels}"

        # Call the inference method directly instead of _call
        messages = []
        if sys_prompt:
            messages.append({"role": "system", "content": sys_prompt})
        messages.append({"role": "user", "content": user_prompt})

        # Process the model's output
        retry = 0
        while retry < 3:
            processed_output_text = self._call(
                user_prompt, sys_prompt=sys_prompt, max_tokens=4096, *args, **kwargs
            ).strip()

            if self.parse_action(
                messages, processed_output_text, labels, image=image
            ).action:
                break
            log_variable(
                "failed_action_model_output",
                {
                    "prompt": user_prompt,
                    "sys_prompt": sys_prompt,
                    "model_output": processed_output_text,
                },
            )
            retry += 1

        log_variable(
            "action_model_output",
            processed_output_text,
        )

        if retry == 3:
            raise RuntimeError(
                "Failed to parse action after 3 attempts. Please check the model output."
            )

        return self.parse_action(messages, processed_output_text, labels, image=image)

    def parse_action(
        self, prompt: list[dict[str, str]], model_response: str, labels, image=None
    ) -> Action:
        """
        Parse JSON-formatted action response

        :param prompt: The original prompt given to the model
        :param model_response: The model's JSON response
        :param labels: The labels generated by OmniParser
        :param image: The image used for the action
        :return: An Action object with parsed action details
        """
        # Extract JSON content from the response
        json_pattern = r"```json\s*(.*?)\s*```"
        json_match = re.search(json_pattern, model_response, re.DOTALL)

        if json_match:
            json_str = json_match.group(1)
        else:
            # If not found between code blocks, try to find a JSON object directly
            json_pattern = r"\{.*\}"
            json_match = re.search(json_pattern, model_response, re.DOTALL)
            if json_match:
                json_str = json_match.group(0)
            else:
                # Fall back to the old regex pattern for backward compatibility
                return self._parse_action_with_regex(prompt, model_response)

        try:
            action_data = json.loads(json_str)

            # Extract action details from the JSON
            context_analysis = action_data.get("context_analysis", "")

            action_info = action_data.get("action", {})
            action_type = action_info.get("type", None)

            if "click" in action_type.lower():
                action_target = action_info.get("target", "")
                action_target_id = int(action_info.get("target_id", 0))
                action_target_dict = (
                    labels[action_target_id] if action_target_id else None
                )
                if action_target_dict:
                    width, height = image.size
                    coords = (
                        (
                            (
                                action_target_dict["bbox"][2]
                                + action_target_dict["bbox"][0]
                            )
                            / 2  # normalized x center
                        )
                        * width,  # x
                        (
                            (
                                action_target_dict["bbox"][3]
                                + action_target_dict["bbox"][1]
                            )
                            / 2  # normalized y center
                        )
                        * height,  # y
                    )
                else:
                    raise ValueError(
                        f"Action target ID {action_target_id} not found in labels."
                    )
            else:
                action_target = action_info.get("target", None)
                coords = None

            if not action_type:
                # Fall back to the old regex pattern for backward compatibility
                return self._parse_action_with_regex(prompt, model_response)

            return Action(
                prompt,
                model_response,
                action_target,
                action=action_type,
                reasoning=context_analysis,
                coords=coords,
            )

        except json.JSONDecodeError:
            # Fall back to the old regex pattern for backward compatibility
            return self._parse_action_with_regex(prompt, model_response)

    def _parse_action_with_regex(
        self, prompt: list[dict[str, str]], model_response: str
    ) -> Action:
        """
        Legacy method to parse action using regex patterns for backward compatibility
        """
        reasoning_pattern = (
            r"<\|context_analysis_begin\|>(.*?)<\|context_analysis_end\|>"
        )
        action_name_pattern = r"<\|action_begin\|>(.*?)<\|action_end\|>"
        action_target_pattern = r"\[(.*)\]"

        reasoning_match = re.search(reasoning_pattern, model_response, re.DOTALL)
        action_name_match = re.search(action_name_pattern, model_response, re.DOTALL)
        action_target_match = re.search(
            action_target_pattern, model_response, re.DOTALL
        )

        reasoning_content = (
            reasoning_match.group(1).strip() if reasoning_match else None
        )
        action_name_content = (
            action_name_match.group(1).strip() if action_name_match else None
        )
        action_target_content: str | None = (
            action_target_match.group(1).strip() if action_target_match else None
        )

        if reasoning_content is None:
            return Action(
                prompt, action_target_content, model_response, action_name_content
            )

        reasoning = re.split(r"\n\d+\.\s", reasoning_content)

        return Action(
            prompt,
            model_response,
            action_target_content,
            action=action_name_content,
            reasoning=reasoning,
        )
